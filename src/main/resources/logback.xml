<configuration scan="true" scanPeriod="5 seconds">
    <!--%logger{length} - выводит имя объекта логгирования. Этот оператор принимает целое число в качестве параметра. Алгоритм сокращает имя
    объекта без значительной потери смысла, 0 - приведет к тому, что имя класса будет напечатано без префикса имени пакета, а
    по умолчанию имя будет напечатано полностью.
    Пример: если{5} l.e.j.JdbcExecutor; если{36} liquibase.executor.jvm.JdbcExecutor-->
    <!--d{pattern,timezone} - используется для вывода даты логгирования. Синтаксис шаблона совместим с форматом java.text.SimpleDateFormat.
     При отстутствии шаблона используется шаблон "ISO8601". Параметр timezone указывает часовой пояс. При отсутствии параметра будет указан
     часовой пояс по умолчанию для хост-платформы Java-->
    <!--relative - выводит количество миллисекунд, прошедших с момента запуска приложения дл создания события логгирования-->
    <!--[%thread] - выводит имя логгируемого потока-->
    <!--%level - выводит уровень события логгирования (info/debug/error/trace/warn)-->
    <!--%msg - выводит сообщение, связанное с событием логгирование.-->
    <!--%n - символ разделителя строк (иначе все сообщения будут в одно строку)-->
    <!--% - символ, которым отмечаются слова преобразователи-->

    <!--%-5logger - выравнивание по ширине на указанное количество символов (включая символы самого уровня логгирования)
     -5 - выравнивание по правому краю, 5 - по левому-->
    <!--%-1.logger - усечение уровня логгирование до указанного количества символов-->

    <!--replace(p){r,t}) - где 'r' регулярное выражение, которое будет изменено на значение 't' в строке 'p'.
     Пример: %replace(%msg){'INTO [a-z_]+', 'xxxx'}%n - имя всех таблиц в логах будут маскироваться значением 'xxxx' -->

    <!--в logback можно группировать подшаблоны и применять к ним директивы форматирования.
    Пример: %-30(%d{HH:mm:ss} [%thread])... - отступ 30 символов перед выводом уровня логгирования-->

    <!--%highlight(%level) - автоматически устанавливает цвет для error:bold-red, warn:red, info:blue -->
    <!--%cyan() - цветовая группировка, позволят изменить цвет выбранного шаблона. Имеет несколько разных цветов-->

    <!--Evaluator - при выполнении заданного условия выводит информацию о вызывающем классе на консоль.
    ...%m$n%caller(depth, evaluator) - применить evaluator для паттерна логгирования
    Так же можно подавить трасировку ислючений заданного типа
    ...%m%n%ex{depth, evaluator} - применить evaluator для паттерна логирования-->
    <evaluator name="DISP_CALLER_EVAL">
        <expression>
            logger.contains("com.accenture") &amp;
            message.contains("Hello there")
        </expression>
    </evaluator>
    <evaluator name="DISP_EX_EVAL">
        <expression>
            throwable != null &amp; throwable instanceof
            com.accenture.usefultricks.exception.CustomException
        </expression>
    </evaluator>

    <!--Можно подключить конфигурацию из другого файла, подключаемое содержимое обязательно должно
    содержаться в тегах <included>. Содержимое можно подключить по имени файла, ресурса или URL-->
    <include resource="includedLogback.xml"/>

    <!--conversionRule - бъявляем новое "слово-преобразование" и используем для паттерна логгирования %nanos-->
    <conversionRule conversionWord="nanos"
                    converterClass="com.accenture.usefultricks.logback.CustomLogback" />

    <!--contextName - наименование сценария конфигурации. По умолчанию default.
    Позволяет разлечить логгирование одних и тех же классов разными сценариями-->
    <contextName>writeToFileApp</contextName>

    <!--property - создание переменной. ${property-name} - применение.
    Подстановка переменных может происходить в любом месте файла конфигурации, где можно указать значение (value). -->
    <!--В случае, если переменная не объявлена, можно указать значение по умолчанию с помощью оператора ":-"
    Например: ${log_dir_name:-DEFAULT_DIR}-->
    <property name="log_pattern" value="%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n"/>
    <property name="log_pattern_console"
              value="%-65(%d{HH:mm:ss.SSS} [%thread] %highlight(%.-1level) %cyan(%-36logger{36})) - %replace(%msg){'INTO [a-z_]+', 'xxxx'}%n"/>
    <property name="log_path" value="LOGGING_RECORDS"/>
    <!--Так же возможно подключение отдельного файла с параметрами-->
    <property resource="variables.properties" />

    <!--rollingPolicy - условия, при которых запись начнется в новый файл
    - fileNamePattern - файл будет генерироваться снова для каждого периода указанного в значение fileNamePattern,
    паттерн по умолчанию для %d:yyy-MM-dd, можно указать несколько спецификаторов d{}, но только одна из них
    может быть использован для периуда ролловера, все остальные должны быть помечены параметром aux, например: %d{yyyy/MM, aux}
    maxHistory - это свойство контролирует максималное количество сохраняемых лог-файлов и должно применяться первым,
    пример: если указать ежемесячный ролловер %d{yyyy-MM} и maxHistory=6, то файлы старше 6 месяцев будут удалены, т.е.
    для ежедневного ролловера в течении одного месяца, необходимо будет указать %d{yyyy-MM-dd} и maxHistory=30
    - maxFileSize - each archived file, size max 10MB
    - totalSizeCap - контролирует общий размер всех лог-файлов, при привышении заданного размера, самые старые
    файлы будут удаляться, данное свойство должно применяться вторым, после maxHistory.
    - maxFileSize - устанавлвает максимальный размер для каждого лог-файла в отдельности.
    - токен %i является обязательным при использовании свойста maxFileSize. Каждый раз, когда текущий лог-файл
    будет достигать максимального значения до окончания текущего периода премени, он будет архивироваться
    с наростающим индексом, начиная с 0-->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${log_path}/report-print.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${log_path}/report-print-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <maxFileSize>10MB</maxFileSize>
            <maxHistory>5</maxHistory>
            <totalSizeCap>1GB</totalSizeCap>
        </rollingPolicy>
        <encoder>
            <pattern>${log_pattern}</pattern>
        </encoder>
    </appender>

    <!--outputPatternAsHeader - это свойство выводит используемый шаблон
    в начале журнала логов, по умолчанию выключено-->
    <!--LevelFilter - фильтрует события на основе точного соответствия уровня
    - ThresholdFilter - фильтрует события которые равны или ниже указанного,
    все события выше будут откланены (DENY)
    - EvaluatorFilter - принимает блок языка Java, возвращающий логическое значение,
    в даннном случае, если выражение "return message.contains("Custom")" вернет true,
    все записи, содержащие такое сообщение, будут удалены (DENY)-->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <!--<filter class="ch.qos.logback.classic.filter.LevelFilter">-->
            <!--<level>INFO</level>-->
            <!--<onMatch>ACCEPT</onMatch>-->
            <!--<onMismatch>DENY</onMismatch>-->
        <!--</filter>-->

        <!--<filter class="ch.qos.logback.classic.filter.ThresholdFilter">-->
            <!--<level>INFO</level>-->
        <!--</filter>-->

        <!--<filter class="ch.qos.logback.core.filter.EvaluatorFilter">-->
            <!--<evaluator>-->
                <!--<expression>return message.contains("Custom");</expression>-->
            <!--</evaluator>-->
            <!--<OnMatch>DENY</OnMatch>-->
            <!--<OnMismatch>NEUTRAL</OnMismatch>-->
        <!--</filter>-->

        <layout class="ch.qos.logback.classic.PatternLayout">
            <Pattern>${log_pattern_console}</Pattern>
            <outputPatternAsHeader>true</outputPatternAsHeader>
        </layout>
    </appender>

    <!--Сохранение логов в HTML-файле
    Паттер должен быть без пробелов и символов разделения, иначе
    для каждого символа будет создан отдельный столбец.
    Есть возможно подключить свой собственный CSS-->
    <!--appender - сценарий конфиуграции для логгирования
    appender`s class - указывается имя класса для создания экземпляра
    <layout> - имя класса для создания макета
    <encode> - имя класса кодировщика. По умолчанию это класс PatternLayoutEncoder. Encoder отвечает
    за преоразование событий в байтовый массив, а так же запись этого массива в OutputStream
    <append> - true:добавление логов в коней существующего файла, в противном случае false,
    по умолчанию имеет свойство true
    <file> - указывается имя и путь до файла, если файл или родительский каталог
    не существует, они будут созданы автоматически-->
    <appender name="FILE_HTML" class="ch.qos.logback.core.FileAppender">
        <file>${log_path}/log-file.html</file>
        <append>false</append>
        <encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder">
            <layout class="ch.qos.logback.classic.html.HTMLLayout">
                <pattern>%d{HH:mm:ss}%thread%level%logger%msg%mdc</pattern>
            </layout>
        </encoder>
    </appender>

    <!--Сохранения логов в Базу данных
    До использования этого сценария должны быть созданы три таблицы.
    Пример скрипта создания находится в "logback-classic/src/main/java/ch/qos/logback/classic/db/script folder"-->
    <appender name="DB" class="ch.qos.logback.classic.db.DBAppender">
        <connectionSource class="ch.qos.logback.core.db.DriverManagerConnectionSource">
            <driverClass>org.postgresql.Driver</driverClass>
            <url>jdbc:postgresql://localhost:5432/usfl</url>
            <user>postgres</user>
            <password>123</password>
        </connectionSource>
    </appender>

    <!--logger - настройка вывода лога для конкретного имени, не зависит от настроек корневого логгера-->
    <logger name="com.accenture" level="info"/>
    <logger name="org.springframework" level="off"/>

    <!--При добавлении <appender-ref> в консоль будут по прежнему выводиться все сообщения, но
     но в файл по данному сценарию будут записываться только логи с именем liquibase
     additivity - этот флаг указывает на то, что лог-файлы будут записываться отдельно от
     основного потока (в консоли выводиться не будут)-->
    <logger name="liquibase" level="info" additivity="false">
        <appender-ref ref="FILE" />
        <appender-ref ref="DB" />
    </logger>

    <!--root - корневой логгер, он поддерживает только настройку атрибута уровня
    Иерархия уровней: TRACE < DEBUG < INFO < WARN < ERROR (ALL, OFF)
    Каждый последующий уровень включает в себя предыдущий
    Корневой уровень по умолчанию DEBUG-->
    <!--Appenders присоединяются к корневому логгеру по тегу appender-ref-->
    <root level="error">
        <!--<appender-ref ref="FILE" />-->
        <appender-ref ref="CONSOLE" />
        <!--<appender-ref ref="FILE_HTML" />-->
        <!--<appender-ref ref="INCLUDED_FILE_HTML" />-->
    </root>
</configuration>